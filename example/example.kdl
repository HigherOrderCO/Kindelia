// Kindelia Example Block
// ======================
// 
// This is an example Kindelia block. Kindelia blocks are just pages of code
// that are interpreted by Kindelia's global computer. To run this example,
// install Kindelia and type:
// 
// $ kindelia run example.kdl
// 
// Kindelia's HVM
// ==============
// 
// Kindelia blocks use HVM internally, with some changes and additions:
// 
// - Letters are 6-bit chars on the set: 
//   
//     .ABCDEFGHIJKLMNO
//     PQRSTUVWXYZabcde
//     fghijklmnopqrstu
//     vwxyz0123456789_
//
// - Variables can have up to 3 letters (18 bits)
//
// - Names can have up to 10 letters (60 bits)
//
// - Constructors are written as `$(CtrName arg_0 arg_1 ...)`
//
// - Function calls are written as `!(FunName arg_0 arg_1 ...)`
//
// - Integers are 120-bit, and are written like `#123`
// 
// - You can also write a number with a name, like `'Foo'`
//
// - Functions can hold an internal state
//
// - Files are groups of statements, each altering the blockchain state
//
// - Constructors must be declared on the top-level, including name and fields:
//
//     $(Name field_0 field_1 ...)
// 
// - Functions must be declared on the top-level, including:
//   - Its name and arguments
//   - As a set of equations
//   - An initial state
//
//     !(Function arg0 arg1 ...) {
//       !(Ctor0 arg_0 arg_1 ...) = return_0
//       !(Ctor1 arg_0 arg_1 ...) = return_1
//       ...
//     } = initial_state
// 
// - IO actions can be performed with IO statements:
//
//     {
//       IO_expression
//     }
//
// - The following IO actions are available:
//
//     - IO.done value       -- completes the IO action
//     - IO.take             -- returns the internal state
//     - IO.save value       -- sets the internal state
//     - IO.call fname ioexp -- calls an IO function
//     - IO.from             -- returns the caller name
// 
// - This is a prototype. All the above is subject to change!

// Example counter function (contract)
// ===================================

// Creates a Counter function with 2 actions:
$(Inc) // incs its counter
$(Get) // reads its counter
!(Counter action) {
  !(Counter $(Inc)) = $(IO.take @x $(IO.save (+ x #1) @~ $(IO.done #0)))
  !(Counter $(Get)) = !(IO.load @x $(IO.done x))
} = #0 // initial state = #0

// Runs a script that increments the Counter's state 3 times
{
  $(IO.call 'Counter' $(Tuple1 $(Inc)) @~
  $(IO.call 'Counter' $(Tuple1 $(Inc)) @~
  $(IO.call 'Counter' $(Tuple1 $(Inc)) @~
  $(IO.done #0))))
}

// Runs a script that prints the Counter's state
{
  $(IO.call 'Counter' $(Tuple1 $(Get)) @x
  $(IO.done x))
}

// Example datatype and algorithm
// ==============================

// Declares a constructor, Leaf, with arity (size) 1
$(Leaf value)

// Declares a constructor, Node, with arity (size) 2
$(Node left right)

// Declares a pure function, Gen, that receives a
// num and returns a tree with 2^num copies of #1
!(Gen depth) {
  !(Gen #0) = $(Leaf #1)
  !(Gen  x) = &{x0 x1} = x; $(Node !(Gen (- x0 #1)) !(Gen (- x1 #1)))
} = #0

// Declares a pure function that sums a tree
!(Sum tree) {
  !(Sum $(Leaf x))   = x
  !(Sum $(Node a b)) = (+ !(Sum a) !(Sum b))
} = #0

// Run statement that creates a tree with 2^21
// numbers, sums them all and prints the result:
{
  $(IO.done !(Sum !(Gen #21)))
}

// Example account
// ===============

// Utility that, when called, returns the caller name
!(WhoIs) {
  !(WhoIs) = $(IO.from @who $(IO.done who))
} = #0

// Creates the LadyAlice account. It just receives a `$(CallN ...)`
// action and calls another function directly. When that is done,
// that function's 'caller' will be set to LadyAlice, so it works as if
// LadyAlice is an user of that other function. Note that this account
// isn't checking signatures, so anyone can act on LadyAlice's behalf.
!(LadyAlice name args) {
  !(LadyAlice name args) = $(IO.call name args @res $(IO.done res))
} = #0

// Prints LadyAlice's name
{
  $(IO.call 'LadyAlice' $(Tuple2 'WhoIs' $(Tuple0)) @nam
  $(IO.done nam))
}

// (LadyAlice (Call expr code sign)) 

// Example failure
// ===============

// When a transaction fails, it is fully reversed
{
  $(IO.call 'Counter' $(Tuple1 $(Inc)) @~
  $(Sum #0)) // runtime type error
}

// Here, the count wasn't incremented, even though
// the last transaction called `!(Count $(Inc))`
{
  $(IO.call 'Counter' $(Tuple1 $(Get)) @x
  $(IO.done x))
}
