// Kindelia Example Block
// ======================
// 
// This is an example Kindelia block. Kindelia blocks are just pages of code
// that are interpreted by Kindelia's global computer. To run this example,
// install Kindelia and type:
// 
// $ kindelia run example.kdl
// 
// Kindelia's HVM
// ==============
// 
// Kindelia blocks use HVM internally, with some changes and additions:
// 
// - Letters are 6-bit chars on the set: 
//   
//     .ABCDEFGHIJKLMNO
//     PQRSTUVWXYZabcde
//     fghijklmnopqrstu
//     vwxyz0123456789_
//
// - Variables can have up to 3 letters (18 bits)
//
// - Names can have up to 10 letters (60 bits)
//
// - Constructors are written as `$(CtrName arg_0 arg_1 ...)`
//
// - Function calls are written as `!(FunName arg_0 arg_1 ...)`
//
// - Integers are 120-bit, and are written like `#123`
// 
// - You can also write a number with a name, like `@Foo`
//
// - Functions can hold an internal state
//
// - Files are groups of statements, each altering the blockchain state
//
// - Constructors must be declared with 'ctr' statements:
//
//     ctr Name arity
// 
// - Functions must be declared with 'fun' statements:
//
//     fun Name arity {
//       !(Name arg_0 arg_1) = return
//       !(Name arg_0 arg_1) = return
//       ...
//     } = initial_state
// 
// - IO actions can be performed with Run statements:
//
//     run {
//       IO_expression
//     }
//
// - The following IO actions are available:
//
//     - IO.done value       -- completes the IO action
//     - IO.load             -- returns the internal state
//     - IO.save value       -- sets the internal state
//     - IO.call fname ioexp -- calls an IO function
//     - IO.from             -- returns the caller name
// 
// - This is a prototype. All the above is subject to change!

// Example counter function (contract)
// ===================================

// Creates a Count function with 3 actions:
// - Inc: increment its counter, return 0
// - Dec: decrement its counter, return 0
// - Get: return its counter
// And an initial state of zero (#0)
fun Count 1 {
  !(Count $(Inc)) = $(IO.load λx $(IO.save (+ x #1) λ~ $(IO.done #0)))
  !(Count $(Dob)) = $(IO.load λx $(IO.save (* x #2) λ~ $(IO.done #0)))
  !(Count $(Get)) = $(IO.load λx $(IO.done x))
} = #0

// Runs a script that increments the Count's state 3 times
run {
  $(IO.call @Count $(Tuple1 $(Inc)) λ~
  $(IO.call @Count $(Tuple1 $(Inc)) λ~
  $(IO.call @Count $(Tuple1 $(Inc)) λ~
  $(IO.done #0))))
}

// Runs a script that prints the Count's state
run {
  $(IO.call @Count $(Tuple1 $(Get)) λx
  $(IO.done x))
}

// Example datatype and algorithm
// ==============================

// Declares a constructor, Leaf, with arity (size) 1
ctr Leaf 1

// Declares a constructor, Node, with arity (size) 2
ctr Node 2

// Declares a pure function, Gen, that receives a
// num and returns a tree with 2^num copies of #1
fun Gen 1 {
  !(Gen #0) = $(Leaf #1)
  !(Gen  x) = &{x0 x1} = x; $(Node !(Gen (- x0 #1)) !(Gen (- x1 #1)))
} = #0

// Declares a pure function that sums a tree
fun Sum 1 {
  !(Sum $(Leaf x))   = x
  !(Sum $(Node a b)) = (+ !(Sum a) !(Sum b))
} = #0

// Run statement that creates a tree with 2^21
// numbers, sums them all and prints the result:
run {
  $(IO.done !(Sum !(Gen #10)))
}

// Example account
// ===============

// Utility that, when called, returns the caller name
fun WhoIs 0 {
  !(WhoIs) = $(IO.from λwho $(IO.done who))
} = #0

// Creates the LadyAlice account. It just receives a `$(CallN ...)`
// action and calls another function directly. When that is done,
// that function's 'caller' will be set to LadyAlice, so it works as if
// LadyAlice is an user of that other function. Note that this account
// isn't checking signatures, so anyone can act on LadyAlice's behalf.
fun LadyAlice 2 {
  !(LadyAlice name args) = $(IO.call name args λres $(IO.done res))
} = #0

// Prints LadyAlice's name
run {
  $(IO.call @LadyAlice $(Tuple2 @WhoIs $(Tuple0)) λnam
  $(IO.done nam))
}

// (LadyAlice (Call expr code sign)) 

// Example failure
// ===============

// When a transaction fails, it is fully reversed
run {
  $(IO.call @Count $(Tuple1 $(Inc)) λ~
  $(Foo))
}

// Here, the count wasn't incremented, even though
// the last transaction called `!(Count $(Inc))`
run {
  $(IO.call @Count $(Tuple1 $(Get)) λx
  $(IO.done x))
}
