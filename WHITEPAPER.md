Kindelia: a peer-to-peer functional computer
============================================

Turing-complete blockchains, such as Ethereum, allow users to create
decentralized applications (DApps), but recurrent security exploits undermine
the proposal. Formal verification techniques can be used to ensure a DApp has no
exploits, but Ethereum's underlying processor, the EVM, make these too expensive
to be viable. By leveraging a functional virtual machine, the HVM, Kindelia is
able to run formally verified DApps cheaply and efficiently. Moreover, extensive
low-level optimizations let it sustain an much higher layer-1 throughput,
compared to alternatives. Finally, Kindelia has no built-in token, and, thus,
isn't a cryptocurrency; instead, it is merely a peer-to-peer computer capable of
hosting secure functional programs.

Introduction
============

Bitcoin was released in 2009, and became the first successful decentralized
application, or DApp. Soon enough, the community started forking it to create
all sorts of special-purpose coins; for example, NameCoin allowed purchasing and
selling names, and ColorCoin allowed for multiple tokens in a single network. In
2013, Ethereum generalized this concept by including a stateful, Turing complete
virtual machine on its network. Arbitrary DApps could be easily created as
Ethereum contracts, without launching a new network, and making cross-DApp
communication possible. More than a decentralized application, Ethereum was the
first decentralized computer.

Due to its quick development, though, Ethereum launched with several
inefficiencies and design mistakes that made it considerably less scalable and,
most importantly, secure than it should. In 2021, the average Ethereum
transaction fee rose to as much as 70 USD [citation], and multi-millionaire
smart-contract exploits became so common that websites were designed to track
their ocurrences [citation].

- Regarding **scalability**, layer-2 techniques are proposed as a solution, but
  these come with their own compromises. There is value in a more scalable
  layer-1, but Ethereum's historical mistakes leave little room for improvement.

- Regarding **security**, formal verification techniques allow developers to
  deploy contracts with zero bugs on their first version; which is invaluable,
  since they can't be patched or reversed; but the EVM makes these prohibitively
  expensive [citation].

Kindelia is a complete rework of Ethereum's unrelying concept, taking in account
what was learned in the last years, with the intent of making the most efficient
and secure decentralized computer physically possible. It doesn't bring any
novel concept; instead, it just employs a wide range of low-level optimizations
over consolidated ideas in order to make a stable, inexpensive, safe layer-1
computation network, saving every possible bit and making conservative choices
when needed. Computationally, it replaces the EVM by the HVM, a blazingly fast
functional virtual machine that makes ultra-secure, formally verified contracts
economically viable, and enables structural changes that further improve the
efficiency, security and scalability of stateful virtual worlds like games and
markets.

Comparisons to Ethereum
=======================

**HVM makes formally verified DApps much cheaper.**

Formal verification can be used to mathematically ensure that a program can't be
exploited, which is invaluable for a network where programs can't be patched or
reversed. Ethereum's virtual machine is too inefficient for functional programs
[citation], making formal verification unpractical, because one must either
verify the generated bytecode (expensive development) or use a proof language
such as Idris (expensive transactions).

Kindelia adopts the blazingly fast High-order Virtual Machine (HVM), which
features beta-reduction and pattern-matching as native opcodes, allowing
developers to write formally verified programs in a proper proof assistant, and
execute these programs directly and cheaply onchain.

**Reversible heaps make stateful DApps much cheaper.**

One of the most expensive operations on Ethereum is SSTORE, which saves
persistent state to `U256 -> U256` maps. It costs 20000 gas (4k MULs) for a new
store, and 5000 (1k MULs) for a reused store. That cost is high for two reasons:
first, to limit the state growth; second, because a single store demands a
Merkle Patricia Tree insertion, which requires expensive hashes and disk writes.

Kindelia treats state differently: it just saves reversible snapshots of HVM's
heap. Because of that, a SSTORE is a single hashmap insertion, which is
computationally negligible. Increasing the state is still expensive, but reused
stores are, essentially, free. This enables a whole new world of applications
that were prohibitely expensive on Ethereum. That also means contracts can
persist states directly, as immutable structures, with no need for
serialization. This further decreases computational costs, and makes bugs even
less likely.

**The block structure is astonishingly simpler.**

There are no merkle roots, bloom filters, logs, receipts. Kindelia's blocks are
refreshingly simple: just a timestamp, the previous hash, a nonce, the miner id,
and a body of statements (transactions). The body is only *1280 bytes* long, and
is fully included in the header. The entire block fits in a single UDP packet,
enabling fast propagation and short block times, with minimal uncle rate.

**Transactions are replaced by arbitrary code blocks.**

Instead of monetary "from/to" transactions, Kindelia blocks are just lists of
statements that perform an action on Kindelia's global state. In other words,
blocks can be seen as pages of code that are executed on Kindelia's REPL
(read-eval-print loop). That flexibility enables important optimizations, such
as unsigned transactions, making certain interactions, such as contract
deployment, considerably cheaper.

**Contract functions are globally reusable.**

Instead of compiling every function in a contract to a flat bytecode, Kindelia
programs are broken into pure functions that are deployed separately, in a
modular fashion. That means that any program can call any function from any
other program, as if it was their own. This enables an enourmous amount of code
reuse, making contracts even more lightweight and cheap.

**Accounts are fully abstracted.**

There is no built-in account system; in fact, a full node doesn't need to import
a single signature algorithm! Kindelia accounts are just user-deployed functions
that conditionally call other functions based on whatever signature schemes they
choose. This not only enables all sorts of login schemes to be designed, but
also makes Kindelia inherently immune to quantum attacks, which would
irreversibly collapse both Ethereum and Bitcoin.

**There is no native currency.**

There is no built-in currency either, which means Kindelia isn't a
cryptocurrency and, by definition, has no premine. To prevent spam, Kindelia
imposes 3 hard limits on a full node's resource usage: the blockchain growth
(about `40 GB` per year), the state growth (about `2 GB` per year) and the
computation growth (about `1.3 * 10^18 mana` per year). When the maximum
capacity is reached, miners will start cherry picking transactions, thus a fee
market will naturally emerge, allowing users to pay miners in any internal asset
they like, instead of just a single official token.

Technical Overview
==================

Technically, Kindelia is just a REPL that interprets sequential blocks of
statements in a functional language to compute a final state. These blocks are
ordered by a network of miners following a consensus algorithm. Statements can
be one of 4 variants:

- **use**: defines a block-wide name alias

    ```c
    use ShortName = LongName 
    ```

- **ctr**: declares a new constructor

    ```c
    ctr Name(field_0_name, field_1_name, ...)
    ```


- **fun**: declares a new function 

    ```c
    fun Name arity {
      !(Name arg_0 arg_1 ...) = <returned_value>
      !(Name arg_0 arg_1 ...) = <returned_value>
      ...
    } = <initial_state>
    ```

- **run**: runs an IO expression

    ```c
    run ManaLimit {
      <io_expression>
    }
    ```

A Kindelia expression is a term in a pure, side-effect free, affine functional
language with 8 variants. Its grammar is described below:

```c
// A native number
Numb = Uint<120>

// a full name
Name = Uint<60>

// A short name
Bind = Uint<12>

// A native int operation
Oper ::=
  +  // addition
  -  // subtraction
  *  // multiplication
  /  // division
  %  // modulus
  &  // bitwise and
  |  // bitwise or
  ^  // bitwise xor
  << // bitwise left shift
  >> // bitwise right shift
  <= // less than
  <  // less than or equal
  == // equal
  >  // greater than or equal
  >= // greater than
  != // not equal

// An expression
Term ::=

  // A lambda
  λ <var0: Bind> <body: Term>
  
  // An application
  (<func: Term> <argm: Term>)
  
  // A constructor
  $(<name: Name> <arg0: Term> <arg1: Term> ... <argN: Term>)
  
  // A function call
  !(<name: Name> <arg0: Term> <arg1: Term> ... <argN: Term>)

  // A native number
  #<numb: Numb>

  // An integer operation
  (<oper: Oper> <val0: Term> <val1: Term>)

  // A cloning operation
  &{<var0: Bind> <var1: Bind>} = <expr: Term>; <body: Term>

  // A variable
  <bind: Bind>
```

For example,

```
λx λy $(Pair (+ x #42) !(F y))
```

Denotes a function that receives two values, `x`, and `y`, and returns a pair
with `x` plus `42` and `F` applied to `y`. In Python, this could be written
as: `lambda x: lambda y: (x + 42, F(y))`. Also, since Kindelia's language is
affine, variables must occur, at most, once. To duplicate values, the clone
operator, `&`, must be used.

While this syntax may look high-level, don't confuse it with a user-facing
language such as Solidity. It is just a direct textual representation of the
actual terms that run inside Kindelia's HVM. It should be seen as Kindelia's
low-level assembly, and developers should use higher-level languages (such as
Kind, Haskell, Idris, Agda, Coq and Lean) that compile to it.

Numbers are written with a `#`, but, as a syntax sugar, they can be also be
written with a `@` followed by a list of 6-bit letters, as follows:

      | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F | 
    --|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
    0 | . | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | 
    1 | P | Q | R | S | T | U | V | W | X | Y | Z | a | b | c | d | e | 
    2 | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | 
    3 | v | w | x | y | z | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | _ | 

So, for example, `@Bar` denotes the number `(0x02 << 12) | (0x1B << 6) | 0x2C`.
That naming convention can be used to give Kindelia-hosted applications
human-readable source codes.

Finally, Kindelia has side-effective operations that allow functions to save
states, request information from the network, etc.:

```c
$(IO.load       λr ...) // loads this function's internal state
$(IO.save value λr ...) // saves this function's internal state
$(IO.call iofun λr ...) // calls another IO function
$(IO.from       λr ...) // gets the caller 60-bit name
... TODO ...            // ...
$(IO.done value)        // returns from the IO action
```

Note that, since Kindelia's language is pure, these side-effects are only
performed when placed directly inside top-level `run{}` blocks, otherwise they
are treated as pure expressions, exactly like Haskell's IO type. To receive
values from the external environment, a continuation (`λr ...`) is used.

Operations
==========

TODO: write explanations

```
(λx body a)
----------- APP-LAM
x <- a
body

({a b} c)
--------------- APP-SUP
&{x0 x1} = c
{(a x0) (b x1)}

&{r s} = λx f
------------- DUP-LAM
&{f0 f1} = f
r <- λx0 f0
s <- λx1 f1
x <- {x0 x1}

&{x y} = {a b}
-------------- DUP-SUP equal
x <- a
y <- b

&{x y} = {a b}
-------------- DUP-SUP (different)
x <- {xA xB}
y <- {yA yB}
&{xA yA} = a
&{xB yB} = b

&{x y} = N
---------- DUP-NUM
x <- N
y <- N

${x y} = (K a b c ...)
---------------------- DUP-CTR
${a0 a1} = a
${b0 b1} = b
${c0 c1} = c
...
x <- (K a0 b0 c0 ...)
y <- (K a1 b1 c1 ...)

${x y} = *
---------- DUP-ERA
x <- *
y <- *

(+ a b)
--------- OP2-NUM
add(a, b)

(+ {a0 a1} b)
--------------------- OP2-SUP-0
let b0 b1 = b
{(+ a0 b0) (+ a1 b1)}

(+ a {b0 b1})
--------------------- OP2-SUP-1
${a0 a1} = a
{(+ a0 b0) (+ a1 b1)}

(F {a0 a1} b c ...)
----------------------------------- FUN-SUP
${b0 b1} = b
${c0 c1} = c
...
{(F a0 b0 c0 ...) (F a1 b1 c1 ...)}

(user-defined)
-------------- FUN-CTR
(user-defined)
```

Cost Table
==========

Since Kindelia's built-in language is Turing complete, it must have a way to
account for, and limit, performed computations; otherwise anyone could freeze
the entire network by deploying infinite loops, or expensive computations. Like
Ethereum, it has a cost table linking primitive operations to a number, which is
called mana instead of gas. Unlike Ethereum, that cost isn't associated with
transactions, but with the block as a whole.

    .------------------------------------------------------.
    | Opcode  | Effect                          | Mana     |
    |---------|---------------------------------|----------|
    | APP-LAM | applies a lambda                | 10       |
    | APP-SUP | applies a superposition         | 20       |
    | OP2-NUM | operates on a number            | 10       |
    | OP2-SUP | operates on a superposition     | 20       |
    | FUN-CTR | pattern-matches a constructor   | 10 + M   |
    | FUN-SUP | pattern-matches a superposition | 10 + A*5 |
    | DUP-LAM | clones a lambda                 | 20       |
    | DUP-NUM | clones a number                 | 10       |
    | DUP-CTR | clones a constructor            | 10 + A*5 |
    | DUP-SUP | clones a superposition          | 20       |
    | DUP-SUP | undoes a superposition          | 10       |
    | DUP-ERA | clones an erasure               | 10       |
    |------------------------------------------------------|
    | * A is the constructor or function arity             |
    | * M is the alloc count of the right-hand side        |
    '------------------------------------------------------'

Each block has a limit of 42 billion mana. If that limit is passed, nodes will
reject that block.

TODO: explain the state growth limit

TODO: explain the blockchain growth limit

Examples
========

Trees Sum
---------

The block below defines a binary tree type, functions to alloc and sum trees,
and runs a script that sums a tree with `2^10` copies of the number `1`:

```c
// Declares a constructor, Leaf, with arity (size) 1
ctr Leaf 1

// Declares a constructor, Node, with arity (size) 2
ctr Node 2

// Returns a tree with 2^num copies of #1
fun Gen 1 {
  !(Gen #0) = $(Leaf #1)
  !(Gen  x) = &{x0 x1} = x; $(Node !(Gen (- x0 #1)) !(Gen (- x1 #1)))
} = #0

// Sums a tree
fun Sum 1 {
  !(Sum $(Leaf x))   = x
  !(Sum $(Node a b)) = (+ !(Sum a) !(Sum b))
} = #0

// Allocates a big tree and sums it:
run {
  $(IO.done !(Sum !(Gen #10)))
}
```

Note that the script at the end of the block above doesn't have any persistent
effect, since it doesn't invoke `IO.save`. It just performs a pure computation
on-chain.

Counter
-------

To be useful, contracts must be able to hold a state. Below, we define a `Count`
contract that has two actions: one to increment a counter, and one to return the
current counter. We then run two scripts: one that increments the counter 3
times, and other that just outputs the current counter, i.e., 3.

```c
// Creates a Count function with 2 actions:
// - Inc: increment its counter, return 0
// - Get: return its counter
// And an initial state of zero (#0)
fun Count 1 {
  !(Count $(Inc)) = $(IO.load λx $(IO.save (+ x #1) λ~ $(IO.done #0)))
  !(Count $(Get)) = $(IO.load λx $(IO.done x))
} = #0

// Runs a script that increments the Count's state 3 times
run {
  $(IO.call !(Count $(Inc)) λ~
  $(IO.call !(Count $(Inc)) λ~
  $(IO.call !(Count $(Inc)) λ~
  $(IO.done #0))))
}

// Runs a script that prints the Count's state
run {
  $(IO.call !(Count $(Get)) λx
  $(IO.done x))
}
```

Account
-------

A Kindelia account is just a function that receives an action and a signature,
and, if the signature checks, calls another function to perform that action. For
example:

```c
fun Alice 1 {
  !(Alice $(SendCoin amount to nonce signature)) =
    
    let pub_key = ... alice key here ...
    let sig_key = !(ECDSA.recv signature !(Hash [amount to nonce]))

    if (== sig_key pub_key) then
      $(Coin.send amount to nonce)
    else
      $(IO.done #0)
} = #0
```

As soon as the function above is deployed, Alice may use it as her own account
to send coins in an hypothetical "Coin" contract, because only herself is able
to call it with a signature that enters the `Coin.send` branch. Of course, this
account is extremelly limited, but anything is possible. Alice could have a
collection of signature schemes, she could impose limitations, and could extend
her own account's functionality by storing lambdas on its internal state.

Serialization
=============

TODO: write the serialization format
